2001-12-01  Olivier Hainque <hainque@act-europe.fr>

	* unroll.c (loop_iterations): Give up on jumps with null JUMP_LABEL
	while scanning for multiple back edges.

2001-10-11  Franz Sirl  <Franz.Sirl-kernel@lauterbach.com>

	* unroll.c (loop_iterations): Fixup last patch.

2001-10-10  Franz Sirl  <Franz.Sirl-kernel@lauterbach.com>

	PR c++/4512
	* unroll.c (loop_iterations): Ignore insns generated by loop
	unrolling.

2001-11-19  Geoffrey Keating  <geoffk@redhat.com>

        * gcc.c-torture/execute/20011008-3.c: Allow for small STACK_SIZE.

2001-10-08  Franz Sirl  <Franz.Sirl-kernel@lauterbach.com>

	* gcc.c-torture/execute/20011008-3.c: New.

--- gcc/unroll.c.jj	Wed Mar 13 22:53:13 2002
+++ gcc/unroll.c	Fri Apr 12 21:14:12 2002
@@ -3698,6 +3698,44 @@ loop_iterations (loop)
       return 0;
     }
 
+  /* If there are multiple conditionalized loop exit tests, they may jump
+     back to differing CODE_LABELs.  */
+  if (loop->top && loop->cont)
+    {
+      rtx temp = PREV_INSN (last_loop_insn);
+
+      do
+	{
+	  if (GET_CODE (temp) == JUMP_INSN)
+	    {
+	      /* There are some kinds of jumps we can't deal with easily.  */
+	      if (JUMP_LABEL (temp) == 0)
+		{
+		  if (loop_dump_stream)
+		    fprintf
+		      (loop_dump_stream,
+		       "Loop iterations: Jump insn has null JUMP_LABEL.\n");
+		  return 0;
+		}
+
+	      if (/* Previous unrolling may have generated new insns not
+		     covered by the uid_luid array.  */
+		  INSN_UID (JUMP_LABEL (temp)) < max_uid_for_loop
+		  /* Check if we jump back into the loop body.  */
+		  && INSN_LUID (JUMP_LABEL (temp)) > INSN_LUID (loop->top)
+		  && INSN_LUID (JUMP_LABEL (temp)) < INSN_LUID (loop->cont))
+		{
+		  if (loop_dump_stream)
+		    fprintf 
+		      (loop_dump_stream,
+		       "Loop iterations: Loop has multiple back edges.\n");
+		  return 0;
+		}
+	    }
+	}
+      while ((temp = PREV_INSN (temp)) != loop->cont);
+    }
+
   /* Find the iteration variable.  If the last insn is a conditional
      branch, and the insn before tests a register value, make that the
      iteration variable.  */
--- gcc/testsuite/gcc.c-torture/execute/20011008-3.c.jj	Fri Apr 12 21:10:51 2002
+++ gcc/testsuite/gcc.c-torture/execute/20011008-3.c	Fri Apr 12 21:10:46 2002
@@ -0,0 +1,105 @@
+extern void exit (int);
+extern void abort (void);
+
+typedef unsigned int u_int32_t;
+typedef unsigned char u_int8_t;
+typedef int int32_t;
+
+typedef enum {
+        TXNLIST_DELETE,
+        TXNLIST_LSN,
+        TXNLIST_TXNID,
+        TXNLIST_PGNO
+} db_txnlist_type;
+
+struct __db_lsn; typedef struct __db_lsn DB_LSN;
+struct __db_lsn {
+        u_int32_t file;
+        u_int32_t offset;
+};
+struct __db_txnlist; typedef struct __db_txnlist DB_TXNLIST;
+
+struct __db_txnlist {
+        db_txnlist_type type;
+        struct { struct __db_txnlist *le_next; struct __db_txnlist **le_prev; } links;
+        union {
+                struct {
+                        u_int32_t txnid;
+                        int32_t generation;
+                        int32_t aborted;
+                } t;
+                struct {
+
+
+                        u_int32_t flags;
+                        int32_t fileid;
+                        u_int32_t count;
+                        char *fname;
+                } d;
+                struct {
+                        int32_t ntxns;
+                        int32_t maxn;
+                        DB_LSN *lsn_array;
+                } l;
+                struct {
+                        int32_t nentries;
+                        int32_t maxentry;
+                        char *fname;
+                        int32_t fileid;
+                        void *pgno_array;
+                        u_int8_t uid[20];
+                } p;
+        } u;
+};
+
+int log_compare (const DB_LSN *a, const DB_LSN *b)
+{
+  return 1;
+}
+
+
+int
+__db_txnlist_lsnadd(int val, DB_TXNLIST *elp, DB_LSN *lsnp, u_int32_t flags)
+{
+   int i;
+ 
+   for (i = 0; i < (!(flags & (0x1)) ? 1 : elp->u.l.ntxns); i++)
+     {
+	int __j;
+	DB_LSN __tmp;
+	val++; 
+	for (__j = 0; __j < elp->u.l.ntxns - 1; __j++)
+	  if (log_compare(&elp->u.l.lsn_array[__j], &elp->u.l.lsn_array[__j + 1]) < 0)
+	  {
+	     __tmp = elp->u.l.lsn_array[__j];
+	     elp->u.l.lsn_array[__j] = elp->u.l.lsn_array[__j + 1];
+	     elp->u.l.lsn_array[__j + 1] = __tmp;
+	  }
+     }
+
+   *lsnp = elp->u.l.lsn_array[0];
+   return val;
+}
+
+#ifndef STACK_SIZE
+#define	VLEN	1235
+#else
+#define VLEN (STACK_SIZE/10)
+#endif
+
+int main (void)
+{
+  DB_TXNLIST el;
+  DB_LSN lsn, lsn_a[VLEN];
+  
+  el.u.l.ntxns = VLEN-1;
+  el.u.l.lsn_array = lsn_a;
+  
+  if (__db_txnlist_lsnadd (0, &el, &lsn, 0) != 1)
+    abort ();
+  
+  if (__db_txnlist_lsnadd (0, &el, &lsn, 1) != VLEN-1)
+    abort ();
+  
+  exit (0);
+}
--- gcc/testsuite/gcc.dg/20011008-3.c.jj	Fri Apr 12 21:17:32 2002
+++ gcc/testsuite/gcc.dg/20011008-3.c	Fri Apr 12 21:18:28 2002
@@ -0,0 +1,108 @@
+/* { dg-do run } */
+/* { dg-options "-O2 -funroll-all-loops" } */
+
+extern void exit (int);
+extern void abort (void);
+
+typedef unsigned int u_int32_t;
+typedef unsigned char u_int8_t;
+typedef int int32_t;
+
+typedef enum {
+        TXNLIST_DELETE,
+        TXNLIST_LSN,
+        TXNLIST_TXNID,
+        TXNLIST_PGNO
+} db_txnlist_type;
+
+struct __db_lsn; typedef struct __db_lsn DB_LSN;
+struct __db_lsn {
+        u_int32_t file;
+        u_int32_t offset;
+};
+struct __db_txnlist; typedef struct __db_txnlist DB_TXNLIST;
+
+struct __db_txnlist {
+        db_txnlist_type type;
+        struct { struct __db_txnlist *le_next; struct __db_txnlist **le_prev; } links;
+        union {
+                struct {
+                        u_int32_t txnid;
+                        int32_t generation;
+                        int32_t aborted;
+                } t;
+                struct {
+
+
+                        u_int32_t flags;
+                        int32_t fileid;
+                        u_int32_t count;
+                        char *fname;
+                } d;
+                struct {
+                        int32_t ntxns;
+                        int32_t maxn;
+                        DB_LSN *lsn_array;
+                } l;
+                struct {
+                        int32_t nentries;
+                        int32_t maxentry;
+                        char *fname;
+                        int32_t fileid;
+                        void *pgno_array;
+                        u_int8_t uid[20];
+                } p;
+        } u;
+};
+
+int log_compare (const DB_LSN *a, const DB_LSN *b)
+{
+  return 1;
+}
+
+
+int
+__db_txnlist_lsnadd(int val, DB_TXNLIST *elp, DB_LSN *lsnp, u_int32_t flags)
+{
+   int i;
+ 
+   for (i = 0; i < (!(flags & (0x1)) ? 1 : elp->u.l.ntxns); i++)
+     {
+	int __j;
+	DB_LSN __tmp;
+	val++; 
+	for (__j = 0; __j < elp->u.l.ntxns - 1; __j++)
+	  if (log_compare(&elp->u.l.lsn_array[__j], &elp->u.l.lsn_array[__j + 1]) < 0)
+	  {
+	     __tmp = elp->u.l.lsn_array[__j];
+	     elp->u.l.lsn_array[__j] = elp->u.l.lsn_array[__j + 1];
+	     elp->u.l.lsn_array[__j + 1] = __tmp;
+	  }
+     }
+
+   *lsnp = elp->u.l.lsn_array[0];
+   return val;
+}
+
+#ifndef STACK_SIZE
+#define	VLEN	1235
+#else
+#define VLEN (STACK_SIZE/10)
+#endif
+
+int main (void)
+{
+  DB_TXNLIST el;
+  DB_LSN lsn, lsn_a[VLEN];
+  
+  el.u.l.ntxns = VLEN-1;
+  el.u.l.lsn_array = lsn_a;
+  
+  if (__db_txnlist_lsnadd (0, &el, &lsn, 0) != 1)
+    abort ();
+  
+  if (__db_txnlist_lsnadd (0, &el, &lsn, 1) != VLEN-1)
+    abort ();
+  
+  exit (0);
+}
